# 목적

키가 아주 많이 들어있는 하나의 Object vs 키가 하나인 Object를 여럿 만드는것의 퍼포먼스, 메모리 사용량 비교. 

# 배경

4 depth 의 Object tree 를 만들어야 했다. 
각 차원의 Cardinality는 적고, 적고, 적고, 많았다. 
Object에서 각 차원의 배치 순서는 변경할 수 있다.
가장 Cardinality가 많은 집합(차원)을 G 라고 했을 때, 집합 G 하위에 차원이 더 있다면 집합 G의 key 개수만큼 Object를 추가로 생성해야 하고, 집합 G를 Tree의 마지막 단계에 위치시키면 `많은 key를 포함한 Object 1개` 이후에 추가 Object는 생성되지 않는다.
의미적으로 모든 차원의 위상은 동일한데 Cardinality 사이즈에 따라  배치순서를 지정하게되면 마치 G집합이 특별한 무엇인것처럼 보여 가독성을 저해한다. 가독성을 버려가면서 까지 추구할 만한 퍼포먼스 이득이 생기는지를 알고 싶었다. 

# 평가요소

1. 메모리 사용량 배율
2. 실행 시간의 배율

# 실행

node index.js

# 결과

10000 * 10 * 10 * 10 시나리오에서
Cardinality 10000 그룹을 가장 마지막으로 보내 Object 생성을 억제할 경우가 
속도는 1.8배 빠르면서도 메모리 사용량은 60% 수준이었다. 
이 수치는 기하 급수적으로 증가하기 때문에 100 * 10 * 10 * 10 로 설정할 경우 속도는 1.2배 빨라지고 메모리 사용량은 90% 정도에 그친다.


```
m_keys: 414.34ms
m_keys: +82MB : 2MB>>84MB
m_objects: 748.487ms
m_objects: +138MB : 84MB>>222MB
```
